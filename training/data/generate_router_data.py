"""Generate synthetic Router training data in Alpaca JSONL format.

The generated dataset is class-balanced across the 5 Router intent types:
``factual``, ``comparative``, ``multi_hop``, ``exploratory``, ``follow_up``.
Each row is written as:

{
  "instruction": "...",
  "input": "<question>",
  "output": "{\"type\":\"factual\",\"confidence\":0.92}",
  "intent": "factual"
}
"""

from __future__ import annotations

import argparse
import json
import random
from pathlib import Path
from typing import Any

INTENT_TYPES: tuple[str, ...] = (
    "factual",
    "comparative",
    "multi_hop",
    "exploratory",
    "follow_up",
)

DEFAULT_SAMPLES_PER_INTENT = 160
DEFAULT_SEED = 42

_INSTRUCTION = (
    "Classify the user question into one intent type. "
    "Allowed types: factual, comparative, multi_hop, exploratory, follow_up. "
    "Return strict JSON with keys: type, confidence."
)


def generate_router_dataset(
    *,
    samples_per_intent: int = DEFAULT_SAMPLES_PER_INTENT,
    seed: int = DEFAULT_SEED,
) -> list[dict[str, Any]]:
    """Generate a balanced synthetic Router dataset.

    Args:
        samples_per_intent: Number of samples generated per intent class.
        seed: Random seed used to keep generation deterministic.

    Returns:
        A shuffled list of Alpaca-style training rows.
    """
    if samples_per_intent <= 0:
        raise ValueError("samples_per_intent must be > 0")

    rng = random.Random(seed)
    rows: list[dict[str, Any]] = []

    for intent in INTENT_TYPES:
        for idx in range(samples_per_intent):
            question = _build_question(intent=intent, idx=idx, rng=rng)
            confidence = _confidence_for_intent(intent=intent, idx=idx)
            output = json.dumps(
                {"type": intent, "confidence": confidence},
                ensure_ascii=False,
                separators=(",", ":"),
            )
            rows.append(
                {
                    "instruction": _INSTRUCTION,
                    "input": question,
                    "output": output,
                    "intent": intent,
                }
            )

    rng.shuffle(rows)
    return rows


def write_jsonl(rows: list[dict[str, Any]], output_path: Path) -> None:
    """Write generated rows as UTF-8 JSONL.

    Args:
        rows: Dataset rows generated by ``generate_router_dataset``.
        output_path: Destination JSONL file path.
    """
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open("w", encoding="utf-8") as f:
        for row in rows:
            f.write(json.dumps(row, ensure_ascii=False) + "\n")


def _build_question(*, intent: str, idx: int, rng: random.Random) -> str:
    """Build one synthetic question by intent template."""
    entity_a = _pick(
        rng,
        (
            "LoRA",
            "QLoRA",
            "Adapter",
            "Prefix Tuning",
            "FlashAttention",
            "Transformer",
            "RAG",
            "MoE",
            "RLHF",
            "DPO",
            "SFT",
            "Knowledge Distillation",
        ),
        idx,
    )
    entity_b = _pick(
        rng,
        (
            "BERT",
            "GPT-4",
            "Llama-3",
            "Mistral",
            "DeepSeek",
            "Longformer",
            "RoPE",
            "ALiBi",
            "AdaFactor",
            "AdamW",
            "PPO",
            "GRPO",
        ),
        idx + 3,
    )
    metric = _pick(
        rng,
        (
            "memory usage",
            "latency",
            "throughput",
            "inference cost",
            "hallucination rate",
            "factual consistency",
            "sample efficiency",
            "stability",
        ),
        idx + 7,
    )
    topic = _pick(
        rng,
        (
            "efficient fine-tuning",
            "retrieval augmentation",
            "long-context modeling",
            "agentic reasoning",
            "alignment methods",
            "tool-using agents",
            "evaluation benchmarks",
            "multimodal adaptation",
        ),
        idx + 11,
    )

    if intent == "factual":
        templates = (
            "What is {entity_a} in simple terms?",
            "Define {entity_a} and its core purpose.",
            "How does {entity_a} work at a high level?",
            "When should practitioners use {entity_a}?",
            "Give a concise explanation of {entity_a}.",
        )
    elif intent == "comparative":
        templates = (
            "Compare {entity_a} and {entity_b} for {metric}.",
            "What are the key differences between {entity_a} and {entity_b}?",
            "Which is better for production, {entity_a} or {entity_b}, and why?",
            "Contrast {entity_a} vs {entity_b} from a trade-off perspective.",
            "How do {entity_a} and {entity_b} differ in real-world usage?",
        )
    elif intent == "multi_hop":
        templates = (
            "How does {entity_a} influence {entity_b}, and what impact does that have on {metric}?",
            "Explain how {entity_a} relates to {topic}, then infer implications for deployment.",
            "If a system adopts {entity_a}, what changes in {entity_b} and downstream evaluation?",
            "Connect {entity_a} with {entity_b} and derive practical recommendations.",
            "Trace the chain from {entity_a} design choices to outcomes in {metric}.",
        )
    elif intent == "exploratory":
        templates = (
            "What are current research trends in {topic}?",
            "Survey recent directions around {topic} and open problems.",
            "What should I read to understand the landscape of {topic}?",
            "Give a broad overview of methods, benchmarks, and challenges in {topic}.",
            "Where is {topic} heading in the next 1-2 years?",
        )
    elif intent == "follow_up":
        templates = (
            "Can you elaborate on that with a practical example?",
            "What did you mean by the previous point about {metric}?",
            "Could you explain that again in simpler language?",
            "How does that apply to a real project using {entity_a}?",
            "Can you break the last answer into actionable steps?",
        )
    else:
        raise ValueError(f"Unsupported intent: {intent}")

    template = _pick(rng, templates, idx + 17)
    return template.format(entity_a=entity_a, entity_b=entity_b, metric=metric, topic=topic)


def _confidence_for_intent(*, intent: str, idx: int) -> float:
    """Generate deterministic confidence score in [0.80, 0.99]."""
    base_by_intent = {
        "factual": 0.94,
        "comparative": 0.90,
        "multi_hop": 0.87,
        "exploratory": 0.86,
        "follow_up": 0.92,
    }
    base = base_by_intent[intent]
    drift = (idx % 7) * 0.01
    score = base - drift
    return max(0.8, min(round(score, 2), 0.99))


def _pick(rng: random.Random, choices: tuple[str, ...], idx: int) -> str:
    """Select deterministically with slight randomness for variety."""
    offset = rng.randint(0, len(choices) - 1)
    return choices[(idx + offset) % len(choices)]


def _parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Generate Router training dataset JSONL.")
    parser.add_argument(
        "--samples-per-intent",
        type=int,
        default=DEFAULT_SAMPLES_PER_INTENT,
        help="Number of samples to generate per intent class.",
    )
    parser.add_argument(
        "--seed",
        type=int,
        default=DEFAULT_SEED,
        help="Random seed for deterministic generation.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("training/data/router_train.jsonl"),
        help="Output JSONL path.",
    )
    return parser.parse_args()


def main() -> None:
    """Generate and save Router training data."""
    args = _parse_args()
    rows = generate_router_dataset(
        samples_per_intent=args.samples_per_intent,
        seed=args.seed,
    )
    write_jsonl(rows=rows, output_path=args.output)
    print(
        f"Generated {len(rows)} samples "
        f"({args.samples_per_intent} per intent) at: {args.output}"
    )


if __name__ == "__main__":
    main()
